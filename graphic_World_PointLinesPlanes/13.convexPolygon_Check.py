#!/usr/bin/python
# Env: python3
# Rewrite by afei_0and1

'''
13、凸多边形
    假设按照一定顺序输入一组点，将这些点作为多边形的顶点，要求通过编程判断组成的多边形是否为凸多边形。
输入的点组成有如下特点：
（1）顶点至少为三个；
（2）可以保证组成的多边形每个顶点是两条边的汇合点且所有边互不相交；
例如：输入[[0,0], [0,1], [1,1], [1,0]]，将返回True，因为输入的四个点可以组成一个正方形，属于凸多边形。

向量叉乘解题：
    向量叉乘：即向量的积。对向量进行乘法运算，分为点乘和叉乘两种，向量点乘运算结果为一个标量，而向量叉乘
的结果依然是向量。并且，向量叉乘得到的结果向量与原两向量组成的平面是垂直的。
    对于平面上的两个向量来说，叉乘的结果是垂直于此平面的向量，例如：假设平面上的向量A为：（x1, y1, 0），
向量B：(x2, y2, 0)，则叉乘的结果向量C可以表示为(0, 0, x1y2-x2y1)。所以本题只需要通过判断依次构成的
每个内角的两边作为向量进行叉乘的结果是否为同号，如果全部为同号，则说明组成的多边形为凸多边形；如果存在
异号，则为凹多边形。
'''

def convexPolgon_Check(points):
    res = 0
    for i in range(0, len(points) - 2):
        #取出任意三个点
        p1 = points[i]
        p2 = points[i+1]
        p3 = points[i+2]
        #取出两边的横纵坐标
        l1 = [p2[0] - p1[0], p2[1] - p1[1]]
        l2 = [p3[0] - p2[0], p3[1] - p2[1]]
        #叉乘计算
        n = l1[0] *l2[1] - l2[0] * l1[1]
        if res == 0:
            res = n
        #如果叉乘为异号
        elif res * n < 0:
            return False
    #由于取出三个点，上面的循环完成会剩余最后两条边
    #剩余两边叉乘计算
    for i in range(0, 2):
        p1 = []
        p2 = []
        p3 = []
        #取出剩余两条边
        if i == 0:
            p1 = points[len(points) - 2]
            p2 = points[len(points) - 1]
            p3 = points[0]
        else:
            p1 = points[len(points) - 1]
            p2 = points[0]
            p3 = points[1]
        # 取出两边的横纵坐标
        l1 = [p2[0] - p1[0], p2[1] - p1[1]]
        l2 = [p3[0] - p2[0], p3[1] - p2[1]]
        # 叉乘计算
        n = l1[0] * l2[1] - l2[0] * l1[1]
        if res == 0:
            res = n
        # 如果叉乘为异号
        elif res * n < 0:
            return False
    return True

print(convexPolgon_Check([[0,0], [0,1], [1,1], [1,0]]))
'''
Output result：
    True
'''